from fastapi import FastAPI, Depends
from fastapi.openapi.utils import get_openapi
from fastapi.responses import JSONResponse
from fii_orchestrator.presentation.middleware.rate_limit import setup_rate_limiting
from fii_orchestrator.presentation.exceptions import global_exception_handler, FIIOrchestratorException
from fii_orchestrator.infrastructure.di_container import Container

# Criar container de DI
container = Container()

app = FastAPI(
    title="FII Orchestrator API",
    description="""
    ## üèóÔ∏è **API de Orquestra√ß√£o de Fundos Imobili√°rios (FIIs)**
    
    Esta API fornece acesso aos dados coletados e processados de Fundos Imobili√°rios brasileiros.
    
    ### üöÄ **Funcionalidades**
    - **Fundos**: Listagem e consulta de fundos dispon√≠veis
    - **Pre√ßos**: Hist√≥rico de cota√ß√µes e volumes
    - **Cache**: Sistema de cache Redis para performance
    - **Rate Limiting**: Prote√ß√£o contra abuso (100 req/min)
    - **Pagina√ß√£o**: Suporte a pagina√ß√£o em todos os endpoints
    
    ### üìä **Dados Dispon√≠veis**
    - Informa√ß√µes dos fundos (ticker, CNPJ, raz√£o social)
    - Hist√≥rico de pre√ßos e volumes
    - Metadados de coleta e fontes
    
    ### üîß **Tecnologias**
    - **Backend**: FastAPI + Python
    - **Banco**: DuckDB com arquivos Parquet
    - **Cache**: Redis
    - **Rate Limiting**: SlowAPI
    """,
    version="1.0.0",
    contact={
        "name": "FII Orchestrator Team",
        "email": "vitoria.sousa@stone.com.br",
    },
    license_info={
        "name": "MIT",
        "url": "https://opensource.org/licenses/MIT",
    },
    docs_url="/swagger",
    redoc_url="/redoc",
    openapi_url="/openapi.json"
)

# Configurar rate limiting
setup_rate_limiting(app)

# Configurar tratamento de erros global
app.add_exception_handler(Exception, global_exception_handler)

# Configurar container de DI
app.container = container

@app.get("/", tags=["Status"])
async def root():
    """
    ## üè† **Status da API**
    
    Endpoint raiz que retorna informa√ß√µes b√°sicas sobre a API.
    
    ### üìã **Resposta**
    - **message**: Mensagem de boas-vindas
    - **status**: Status da API
    - **version**: Vers√£o atual
    - **timestamp**: Hor√°rio da requisi√ß√£o
    """
    from datetime import datetime
    return {
        "message": "FII Orchestrator API",
        "status": "operational",
        "version": "1.0.0",
        "timestamp": datetime.now().isoformat()
    }

@app.get("/health", tags=["Status"])
async def health_check():
    """
    ## ü©∫ **Health Check**
    
    Endpoint para verificar a sa√∫de da API e servi√ßos dependentes.
    
    ### üìã **Resposta**
    - **status**: Status geral (healthy/unhealthy)
    - **services**: Status de cada servi√ßo
    - **timestamp**: Hor√°rio da verifica√ß√£o
    """
    from datetime import datetime
    import os
    
    # Verificar servi√ßos
    services_status = {
        "duckdb": "healthy",  # Sempre healthy por enquanto
        "redis": "unknown",   # Ser√° verificado quando implementado
        "parquet_files": "unknown"  # Ser√° verificado quando implementado
    }
    
    # Verificar se h√° dados Parquet
    data_dir = os.path.join(os.getcwd(), "data", "bronze")
    if os.path.exists(data_dir):
        services_status["parquet_files"] = "available"
    else:
        services_status["parquet_files"] = "not_found"
    
    overall_status = "healthy" if all(s == "healthy" or s == "available" for s in services_status.values()) else "degraded"
    
    return {
        "status": overall_status,
        "services": services_status,
        "timestamp": datetime.now().isoformat()
    }

@app.get("/stats", tags=["Status"])
async def get_stats():
    """
    ## üìä **Estat√≠sticas da API**
    
    Endpoint para obter estat√≠sticas sobre o uso da API e dados dispon√≠veis.
    
    ### üìã **Resposta**
    - **api_stats**: Estat√≠sticas da API
    - **data_stats**: Estat√≠sticas dos dados
    - **cache_stats**: Estat√≠sticas do cache
    - **timestamp**: Hor√°rio da requisi√ß√£o
    """
    from datetime import datetime
    import os
    
    # Estat√≠sticas da API
    api_stats = {
        "version": "1.0.0",
        "uptime": "running",
        "endpoints": 4,  # root, health, funds, prices
        "rate_limit": "100/minute"
    }
    
    # Estat√≠sticas dos dados
    data_stats = {
        "parquet_files": 0,
        "data_size_mb": 0,
        "last_update": "unknown"
    }
    
    # Verificar dados Parquet
    data_dir = os.path.join(os.getcwd(), "data", "bronze")
    if os.path.exists(data_dir):
        for subdir in ["funds", "prices", "news"]:
            subdir_path = os.path.join(data_dir, subdir)
            if os.path.exists(subdir_path):
                parquet_files = [f for f in os.listdir(subdir_path) if f.endswith('.parquet')]
                data_stats["parquet_files"] += len(parquet_files)
    
    # Estat√≠sticas do cache (ser√£o implementadas quando Redis estiver ativo)
    cache_stats = {
        "redis_status": "not_configured",
        "cache_hits": 0,
        "cache_misses": 0
    }
    
    return {
        "api_stats": api_stats,
        "data_stats": data_stats,
        "cache_stats": cache_stats,
        "timestamp": datetime.now().isoformat()
    }

from fii_orchestrator.presentation.routers import funds

app.include_router(funds.router, prefix="/api/funds", tags=["Fundos"])

from fii_orchestrator.presentation.routers import prices

app.include_router(prices.router, prefix="/api/prices", tags=["Pre√ßos"])
